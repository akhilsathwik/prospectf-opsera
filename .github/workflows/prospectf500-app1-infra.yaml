name: "prospectf500-app1 Infrastructure"

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
      branch:
        description: 'Branch to use (default: prospectf500-app1-opsera)'
        required: false
        default: 'prospectf500-app1-opsera'
        type: string

env:
  AWS_REGION: eu-north-1
  APP_IDENTIFIER: prospectf500-app1
  TENANT: opsera-se
  ENVIRONMENT: dev
  TF_WORKING_DIR: prospectf500-app1-opsera/terraform
  TF_VAR_aws_region: eu-north-1

jobs:
  terraform:
    name: "Terraform Infrastructure"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.TF_WORKING_DIR }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || 'prospectf500-app1-opsera' }}
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          echo "=== AWS Identity ==="
          aws sts get-caller-identity
          echo ""
          echo "=== AWS Region ==="
          echo "Region: ${{ env.AWS_REGION }}"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Create S3 backend bucket if not exists
        # CRITICAL: Backend must exist BEFORE terraform init (runs for ALL actions)
        continue-on-error: true
        run: |
          BUCKET_NAME="${{ env.APP_IDENTIFIER }}-tfstate"
          TABLE_NAME="${{ env.APP_IDENTIFIER }}-tfstate-lock"
          
          echo "=== Checking S3 backend bucket: $BUCKET_NAME ==="
          
          # Create S3 bucket for state
          if ! aws s3 ls "s3://$BUCKET_NAME" 2>/dev/null; then
            echo "Creating S3 bucket: $BUCKET_NAME"
            aws s3 mb "s3://$BUCKET_NAME" --region ${{ env.AWS_REGION }}
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            echo "✓ S3 bucket created successfully"
          else
            echo "✓ S3 bucket already exists"
          fi
          
          # Create DynamoDB table for locking
          echo "=== Checking DynamoDB lock table: $TABLE_NAME ==="
          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Creating DynamoDB table: $TABLE_NAME"
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }}
            echo "Waiting for DynamoDB table to be active..."
            aws dynamodb wait table-exists --table-name "$TABLE_NAME" --region ${{ env.AWS_REGION }}
            echo "✓ DynamoDB table created successfully"
          else
            echo "✓ DynamoDB table already exists"
          fi

      - name: Terraform Init
        run: |
          echo "=== Initializing Terraform ==="
          terraform init -input=false
          echo "✓ Terraform initialized successfully"

      - name: Terraform Plan
        if: ${{ github.event.inputs.action == 'plan' || github.event.inputs.action == 'apply' }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        if: ${{ github.event.inputs.action == 'apply' }}
        run: terraform apply -auto-approve tfplan

      - name: Wait for cluster endpoint updates to propagate
        if: ${{ github.event.inputs.action == 'apply' }}
        run: |
          echo "Waiting for EKS endpoint updates to propagate (this can take 2-5 minutes)..."
          sleep 120
          echo "✓ Waiting period complete"

      - name: Terraform Destroy
        if: ${{ github.event.inputs.action == 'destroy' }}
        run: terraform destroy -auto-approve

      - name: Output infrastructure details
        if: ${{ github.event.inputs.action == 'apply' }}
        run: |
          echo "=== Infrastructure Outputs ==="
          terraform output

          echo ""
          echo "=== Next Steps ==="
          echo "1. Configure kubectl for ArgoCD cluster:"
          echo "   aws eks update-kubeconfig --name ${{ env.APP_IDENTIFIER }}-cd --region ${{ env.AWS_REGION }}"
          echo ""
          echo "2. Install ArgoCD (run install-argocd job)"
          echo ""
          echo "3. Configure kubectl for Workload cluster:"
          echo "   aws eks update-kubeconfig --name ${{ env.APP_IDENTIFIER }}-wrk-${{ env.ENVIRONMENT }} --region ${{ env.AWS_REGION }}"

  install-argocd:
    name: "Install ArgoCD"
    runs-on: ubuntu-latest
    needs: terraform
    if: ${{ github.event.inputs.action == 'apply' }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for ArgoCD cluster to be active
        run: |
          echo "Waiting for ArgoCD cluster to be ACTIVE..."
          # Use shortened cluster name: prospectf500-app1-cd
          aws eks wait cluster-active --name ${{ env.APP_IDENTIFIER }}-cd --region ${{ env.AWS_REGION }}
          echo "ArgoCD cluster is ACTIVE"

      - name: Verify ArgoCD cluster has public endpoint
        run: |
          echo "Checking cluster endpoint configuration..."
          ENDPOINT_TYPE=$(aws eks describe-cluster --name ${{ env.APP_IDENTIFIER }}-cd --region ${{ env.AWS_REGION }} --query 'cluster.resourcesVpcConfig.endpointPublicAccess' --output text)
          echo "Public endpoint enabled: $ENDPOINT_TYPE"
          if [ "$ENDPOINT_TYPE" != "True" ]; then
            echo "ERROR: Cluster does not have public endpoint enabled. Run Terraform apply to update it."
            exit 1
          fi
          echo "✓ Public endpoint is enabled"

      - name: Configure kubectl for ArgoCD cluster
        run: |
          # Use shortened cluster name: prospectf500-app1-cd
          # Force use of public endpoint
          aws eks update-kubeconfig --name ${{ env.APP_IDENTIFIER }}-cd --region ${{ env.AWS_REGION }}
          
          # Verify we're using public endpoint
          echo "Current kubeconfig endpoint:"
          kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' || true
          echo ""

      - name: Wait for ArgoCD API server to be ready
        run: |
          echo "Waiting for API server to be accessible..."
          MAX_ATTEMPTS=60
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if kubectl cluster-info --request-timeout=15s 2>&1 | grep -q "Kubernetes control plane"; then
              echo "✓ API server is ready and accessible"
              kubectl cluster-info
              exit 0
            fi
            ERROR=$(kubectl cluster-info --request-timeout=5s 2>&1 || true)
            if echo "$ERROR" | grep -q "dial tcp.*i/o timeout"; then
              echo "Attempt $i/$MAX_ATTEMPTS: Connection timeout, waiting 15s..."
            elif echo "$ERROR" | grep -q "Forbidden\|403"; then
              echo "Attempt $i/$MAX_ATTEMPTS: Authentication issue, waiting 15s..."
            else
              echo "Attempt $i/$MAX_ATTEMPTS: API server not ready, waiting 15s..."
            fi
            sleep 15
          done
          echo "ERROR: API server not accessible after $MAX_ATTEMPTS attempts"
          echo "This may indicate the cluster endpoint is not public or not ready"
          exit 1

      - name: Install ArgoCD
        run: |
          echo "Creating argocd namespace..."
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f --validate=false

          echo "Installing ArgoCD..."
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml --validate=false

          echo "Waiting for ArgoCD to be ready..."
          kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s

          echo ""
          echo "=== ArgoCD Installation Complete ==="
          echo "Get the admin password with:"
          echo "kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d"

  install-externaldns:
    name: "Install ExternalDNS"
    runs-on: ubuntu-latest
    needs: terraform
    if: ${{ github.event.inputs.action == 'apply' }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for Workload cluster to be active
        run: |
          echo "Waiting for Workload cluster to be ACTIVE..."
          # Use shortened cluster name: prospectf500-app1-wrk-dev
          aws eks wait cluster-active --name ${{ env.APP_IDENTIFIER }}-wrk-${{ env.ENVIRONMENT }} --region ${{ env.AWS_REGION }}
          echo "Workload cluster is ACTIVE"

      - name: Verify Workload cluster has public endpoint
        run: |
          echo "Checking cluster endpoint configuration..."
          ENDPOINT_TYPE=$(aws eks describe-cluster --name ${{ env.APP_IDENTIFIER }}-wrk-${{ env.ENVIRONMENT }} --region ${{ env.AWS_REGION }} --query 'cluster.resourcesVpcConfig.endpointPublicAccess' --output text)
          echo "Public endpoint enabled: $ENDPOINT_TYPE"
          if [ "$ENDPOINT_TYPE" != "True" ]; then
            echo "ERROR: Cluster does not have public endpoint enabled. Run Terraform apply to update it."
            exit 1
          fi
          echo "✓ Public endpoint is enabled"

      - name: Configure kubectl for Workload cluster
        run: |
          # Use shortened cluster name: prospectf500-app1-wrk-dev
          # Force use of public endpoint
          aws eks update-kubeconfig --name ${{ env.APP_IDENTIFIER }}-wrk-${{ env.ENVIRONMENT }} --region ${{ env.AWS_REGION }}
          
          # Verify we're using public endpoint
          echo "Current kubeconfig endpoint:"
          kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' || true
          echo ""

      - name: Wait for Workload API server to be ready
        run: |
          echo "Waiting for API server to be accessible..."
          MAX_ATTEMPTS=60
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if kubectl cluster-info --request-timeout=15s 2>&1 | grep -q "Kubernetes control plane"; then
              echo "✓ API server is ready and accessible"
              kubectl cluster-info
              exit 0
            fi
            ERROR=$(kubectl cluster-info --request-timeout=5s 2>&1 || true)
            if echo "$ERROR" | grep -q "dial tcp.*i/o timeout"; then
              echo "Attempt $i/$MAX_ATTEMPTS: Connection timeout, waiting 15s..."
            elif echo "$ERROR" | grep -q "Forbidden\|403"; then
              echo "Attempt $i/$MAX_ATTEMPTS: Authentication issue, waiting 15s..."
            else
              echo "Attempt $i/$MAX_ATTEMPTS: API server not ready, waiting 15s..."
            fi
            sleep 15
          done
          echo "ERROR: API server not accessible after $MAX_ATTEMPTS attempts"
          echo "This may indicate the cluster endpoint is not public or not ready"
          exit 1

      - name: Get ExternalDNS role ARN
        id: get-role
        run: |
          ROLE_ARN=$(aws iam get-role --role-name ${{ env.APP_IDENTIFIER }}-external-dns --query 'Role.Arn' --output text 2>/dev/null || echo "")
          if [ -z "$ROLE_ARN" ]; then
            echo "ERROR: ExternalDNS IAM role not found. Run Terraform apply first."
            exit 1
          fi
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
          echo "ExternalDNS Role ARN: $ROLE_ARN"

      - name: Install ExternalDNS
        run: |
          cat <<EOF | kubectl apply -f - --validate=false
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: external-dns
            namespace: kube-system
            annotations:
              eks.amazonaws.com/role-arn: ${{ steps.get-role.outputs.role_arn }}
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRole
          metadata:
            name: external-dns
          rules:
          - apiGroups: [""]
            resources: ["services","endpoints","pods","nodes"]
            verbs: ["get","watch","list"]
          - apiGroups: ["extensions","networking.k8s.io"]
            resources: ["ingresses"]
            verbs: ["get","watch","list"]
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: external-dns
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: external-dns
          subjects:
          - kind: ServiceAccount
            name: external-dns
            namespace: kube-system
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: external-dns
            namespace: kube-system
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: external-dns
            template:
              metadata:
                labels:
                  app: external-dns
              spec:
                serviceAccountName: external-dns
                containers:
                - name: external-dns
                  image: registry.k8s.io/external-dns/external-dns:v0.14.0
                  args:
                  - --source=service
                  - --source=ingress
                  - --domain-filter=opsera-labs.com
                  - --provider=aws
                  - --aws-zone-type=public
                  - --registry=txt
                  - --txt-owner-id=${{ env.APP_IDENTIFIER }}-external-dns
          EOF

          echo ""
          echo "=== ExternalDNS Installation Complete ==="
          kubectl get pods -n kube-system -l app=external-dns
